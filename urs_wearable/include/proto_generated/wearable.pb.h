// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: wearable.proto

#ifndef PROTOBUF_wearable_2eproto__INCLUDED
#define PROTOBUF_wearable_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace pb_wearable {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_wearable_2eproto();
void protobuf_AssignDesc_wearable_2eproto();
void protobuf_ShutdownFile_wearable_2eproto();

class WearableRequest;
class GetStatus;
class WearableResponse;
class Status;

enum WearableRequest_WearableRequestType {
  WearableRequest_WearableRequestType_GET_STATUS = 0
};
bool WearableRequest_WearableRequestType_IsValid(int value);
const WearableRequest_WearableRequestType WearableRequest_WearableRequestType_WearableRequestType_MIN = WearableRequest_WearableRequestType_GET_STATUS;
const WearableRequest_WearableRequestType WearableRequest_WearableRequestType_WearableRequestType_MAX = WearableRequest_WearableRequestType_GET_STATUS;
const int WearableRequest_WearableRequestType_WearableRequestType_ARRAYSIZE = WearableRequest_WearableRequestType_WearableRequestType_MAX + 1;

const ::google::protobuf::EnumDescriptor* WearableRequest_WearableRequestType_descriptor();
inline const ::std::string& WearableRequest_WearableRequestType_Name(WearableRequest_WearableRequestType value) {
  return ::google::protobuf::internal::NameOfEnum(
    WearableRequest_WearableRequestType_descriptor(), value);
}
inline bool WearableRequest_WearableRequestType_Parse(
    const ::std::string& name, WearableRequest_WearableRequestType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<WearableRequest_WearableRequestType>(
    WearableRequest_WearableRequestType_descriptor(), name, value);
}
enum WearableResponse_WearableResponseType {
  WearableResponse_WearableResponseType_STATUS = 0
};
bool WearableResponse_WearableResponseType_IsValid(int value);
const WearableResponse_WearableResponseType WearableResponse_WearableResponseType_WearableResponseType_MIN = WearableResponse_WearableResponseType_STATUS;
const WearableResponse_WearableResponseType WearableResponse_WearableResponseType_WearableResponseType_MAX = WearableResponse_WearableResponseType_STATUS;
const int WearableResponse_WearableResponseType_WearableResponseType_ARRAYSIZE = WearableResponse_WearableResponseType_WearableResponseType_MAX + 1;

const ::google::protobuf::EnumDescriptor* WearableResponse_WearableResponseType_descriptor();
inline const ::std::string& WearableResponse_WearableResponseType_Name(WearableResponse_WearableResponseType value) {
  return ::google::protobuf::internal::NameOfEnum(
    WearableResponse_WearableResponseType_descriptor(), value);
}
inline bool WearableResponse_WearableResponseType_Parse(
    const ::std::string& name, WearableResponse_WearableResponseType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<WearableResponse_WearableResponseType>(
    WearableResponse_WearableResponseType_descriptor(), name, value);
}
// ===================================================================

class WearableRequest : public ::google::protobuf::Message {
 public:
  WearableRequest();
  virtual ~WearableRequest();

  WearableRequest(const WearableRequest& from);

  inline WearableRequest& operator=(const WearableRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WearableRequest& default_instance();

  enum WearablerequestOneofCase {
    kGetStatus = 2,
    WEARABLEREQUEST_ONEOF_NOT_SET = 0,
  };

  void Swap(WearableRequest* other);

  // implements Message ----------------------------------------------

  WearableRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const WearableRequest& from);
  void MergeFrom(const WearableRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef WearableRequest_WearableRequestType WearableRequestType;
  static const WearableRequestType GET_STATUS = WearableRequest_WearableRequestType_GET_STATUS;
  static inline bool WearableRequestType_IsValid(int value) {
    return WearableRequest_WearableRequestType_IsValid(value);
  }
  static const WearableRequestType WearableRequestType_MIN =
    WearableRequest_WearableRequestType_WearableRequestType_MIN;
  static const WearableRequestType WearableRequestType_MAX =
    WearableRequest_WearableRequestType_WearableRequestType_MAX;
  static const int WearableRequestType_ARRAYSIZE =
    WearableRequest_WearableRequestType_WearableRequestType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  WearableRequestType_descriptor() {
    return WearableRequest_WearableRequestType_descriptor();
  }
  static inline const ::std::string& WearableRequestType_Name(WearableRequestType value) {
    return WearableRequest_WearableRequestType_Name(value);
  }
  static inline bool WearableRequestType_Parse(const ::std::string& name,
      WearableRequestType* value) {
    return WearableRequest_WearableRequestType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .pb_wearable.WearableRequest.WearableRequestType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::pb_wearable::WearableRequest_WearableRequestType type() const;
  inline void set_type(::pb_wearable::WearableRequest_WearableRequestType value);

  // optional .pb_wearable.GetStatus getStatus = 2;
  inline bool has_getstatus() const;
  inline void clear_getstatus();
  static const int kGetStatusFieldNumber = 2;
  inline const ::pb_wearable::GetStatus& getstatus() const;
  inline ::pb_wearable::GetStatus* mutable_getstatus();
  inline ::pb_wearable::GetStatus* release_getstatus();
  inline void set_allocated_getstatus(::pb_wearable::GetStatus* getstatus);

  inline WearablerequestOneofCase wearablerequest_oneof_case() const;
  // @@protoc_insertion_point(class_scope:pb_wearable.WearableRequest)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_getstatus();

  inline bool has_wearablerequest_oneof();
  void clear_wearablerequest_oneof();
  inline void clear_has_wearablerequest_oneof();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int type_;
  union WearablerequestOneofUnion {
    ::pb_wearable::GetStatus* getstatus_;
  } wearablerequest_oneof_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_AddDesc_wearable_2eproto();
  friend void protobuf_AssignDesc_wearable_2eproto();
  friend void protobuf_ShutdownFile_wearable_2eproto();

  void InitAsDefaultInstance();
  static WearableRequest* default_instance_;
};
// -------------------------------------------------------------------

class GetStatus : public ::google::protobuf::Message {
 public:
  GetStatus();
  virtual ~GetStatus();

  GetStatus(const GetStatus& from);

  inline GetStatus& operator=(const GetStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetStatus& default_instance();

  void Swap(GetStatus* other);

  // implements Message ----------------------------------------------

  GetStatus* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetStatus& from);
  void MergeFrom(const GetStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 uav_id = 1;
  inline bool has_uav_id() const;
  inline void clear_uav_id();
  static const int kUavIdFieldNumber = 1;
  inline ::google::protobuf::int32 uav_id() const;
  inline void set_uav_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:pb_wearable.GetStatus)
 private:
  inline void set_has_uav_id();
  inline void clear_has_uav_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 uav_id_;
  friend void  protobuf_AddDesc_wearable_2eproto();
  friend void protobuf_AssignDesc_wearable_2eproto();
  friend void protobuf_ShutdownFile_wearable_2eproto();

  void InitAsDefaultInstance();
  static GetStatus* default_instance_;
};
// -------------------------------------------------------------------

class WearableResponse : public ::google::protobuf::Message {
 public:
  WearableResponse();
  virtual ~WearableResponse();

  WearableResponse(const WearableResponse& from);

  inline WearableResponse& operator=(const WearableResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WearableResponse& default_instance();

  enum WearableresponseOneofCase {
    kStatus = 2,
    WEARABLERESPONSE_ONEOF_NOT_SET = 0,
  };

  void Swap(WearableResponse* other);

  // implements Message ----------------------------------------------

  WearableResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const WearableResponse& from);
  void MergeFrom(const WearableResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef WearableResponse_WearableResponseType WearableResponseType;
  static const WearableResponseType STATUS = WearableResponse_WearableResponseType_STATUS;
  static inline bool WearableResponseType_IsValid(int value) {
    return WearableResponse_WearableResponseType_IsValid(value);
  }
  static const WearableResponseType WearableResponseType_MIN =
    WearableResponse_WearableResponseType_WearableResponseType_MIN;
  static const WearableResponseType WearableResponseType_MAX =
    WearableResponse_WearableResponseType_WearableResponseType_MAX;
  static const int WearableResponseType_ARRAYSIZE =
    WearableResponse_WearableResponseType_WearableResponseType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  WearableResponseType_descriptor() {
    return WearableResponse_WearableResponseType_descriptor();
  }
  static inline const ::std::string& WearableResponseType_Name(WearableResponseType value) {
    return WearableResponse_WearableResponseType_Name(value);
  }
  static inline bool WearableResponseType_Parse(const ::std::string& name,
      WearableResponseType* value) {
    return WearableResponse_WearableResponseType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .pb_wearable.WearableResponse.WearableResponseType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::pb_wearable::WearableResponse_WearableResponseType type() const;
  inline void set_type(::pb_wearable::WearableResponse_WearableResponseType value);

  // optional .pb_wearable.Status status = 2;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 2;
  inline const ::pb_wearable::Status& status() const;
  inline ::pb_wearable::Status* mutable_status();
  inline ::pb_wearable::Status* release_status();
  inline void set_allocated_status(::pb_wearable::Status* status);

  inline WearableresponseOneofCase wearableresponse_oneof_case() const;
  // @@protoc_insertion_point(class_scope:pb_wearable.WearableResponse)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_status();

  inline bool has_wearableresponse_oneof();
  void clear_wearableresponse_oneof();
  inline void clear_has_wearableresponse_oneof();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int type_;
  union WearableresponseOneofUnion {
    ::pb_wearable::Status* status_;
  } wearableresponse_oneof_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_AddDesc_wearable_2eproto();
  friend void protobuf_AssignDesc_wearable_2eproto();
  friend void protobuf_ShutdownFile_wearable_2eproto();

  void InitAsDefaultInstance();
  static WearableResponse* default_instance_;
};
// -------------------------------------------------------------------

class Status : public ::google::protobuf::Message {
 public:
  Status();
  virtual ~Status();

  Status(const Status& from);

  inline Status& operator=(const Status& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Status& default_instance();

  void Swap(Status* other);

  // implements Message ----------------------------------------------

  Status* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Status& from);
  void MergeFrom(const Status& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline double x() const;
  inline void set_x(double value);

  // optional double y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline double y() const;
  inline void set_y(double value);

  // optional double z = 3;
  inline bool has_z() const;
  inline void clear_z();
  static const int kZFieldNumber = 3;
  inline double z() const;
  inline void set_z(double value);

  // optional double yaw = 4;
  inline bool has_yaw() const;
  inline void clear_yaw();
  static const int kYawFieldNumber = 4;
  inline double yaw() const;
  inline void set_yaw(double value);

  // @@protoc_insertion_point(class_scope:pb_wearable.Status)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_z();
  inline void clear_has_z();
  inline void set_has_yaw();
  inline void clear_has_yaw();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double x_;
  double y_;
  double z_;
  double yaw_;
  friend void  protobuf_AddDesc_wearable_2eproto();
  friend void protobuf_AssignDesc_wearable_2eproto();
  friend void protobuf_ShutdownFile_wearable_2eproto();

  void InitAsDefaultInstance();
  static Status* default_instance_;
};
// ===================================================================


// ===================================================================

// WearableRequest

// required .pb_wearable.WearableRequest.WearableRequestType type = 1;
inline bool WearableRequest::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WearableRequest::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WearableRequest::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WearableRequest::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::pb_wearable::WearableRequest_WearableRequestType WearableRequest::type() const {
  // @@protoc_insertion_point(field_get:pb_wearable.WearableRequest.type)
  return static_cast< ::pb_wearable::WearableRequest_WearableRequestType >(type_);
}
inline void WearableRequest::set_type(::pb_wearable::WearableRequest_WearableRequestType value) {
  assert(::pb_wearable::WearableRequest_WearableRequestType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:pb_wearable.WearableRequest.type)
}

// optional .pb_wearable.GetStatus getStatus = 2;
inline bool WearableRequest::has_getstatus() const {
  return wearablerequest_oneof_case() == kGetStatus;
}
inline void WearableRequest::set_has_getstatus() {
  _oneof_case_[0] = kGetStatus;
}
inline void WearableRequest::clear_getstatus() {
  if (has_getstatus()) {
    delete wearablerequest_oneof_.getstatus_;
    clear_has_wearablerequest_oneof();
  }
}
inline const ::pb_wearable::GetStatus& WearableRequest::getstatus() const {
  return has_getstatus() ? *wearablerequest_oneof_.getstatus_
                      : ::pb_wearable::GetStatus::default_instance();
}
inline ::pb_wearable::GetStatus* WearableRequest::mutable_getstatus() {
  if (!has_getstatus()) {
    clear_wearablerequest_oneof();
    set_has_getstatus();
    wearablerequest_oneof_.getstatus_ = new ::pb_wearable::GetStatus;
  }
  return wearablerequest_oneof_.getstatus_;
}
inline ::pb_wearable::GetStatus* WearableRequest::release_getstatus() {
  if (has_getstatus()) {
    clear_has_wearablerequest_oneof();
    ::pb_wearable::GetStatus* temp = wearablerequest_oneof_.getstatus_;
    wearablerequest_oneof_.getstatus_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void WearableRequest::set_allocated_getstatus(::pb_wearable::GetStatus* getstatus) {
  clear_wearablerequest_oneof();
  if (getstatus) {
    set_has_getstatus();
    wearablerequest_oneof_.getstatus_ = getstatus;
  }
}

inline bool WearableRequest::has_wearablerequest_oneof() {
  return wearablerequest_oneof_case() != WEARABLEREQUEST_ONEOF_NOT_SET;
}
inline void WearableRequest::clear_has_wearablerequest_oneof() {
  _oneof_case_[0] = WEARABLEREQUEST_ONEOF_NOT_SET;
}
inline WearableRequest::WearablerequestOneofCase WearableRequest::wearablerequest_oneof_case() const {
  return WearableRequest::WearablerequestOneofCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// GetStatus

// required int32 uav_id = 1;
inline bool GetStatus::has_uav_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetStatus::set_has_uav_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetStatus::clear_has_uav_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetStatus::clear_uav_id() {
  uav_id_ = 0;
  clear_has_uav_id();
}
inline ::google::protobuf::int32 GetStatus::uav_id() const {
  // @@protoc_insertion_point(field_get:pb_wearable.GetStatus.uav_id)
  return uav_id_;
}
inline void GetStatus::set_uav_id(::google::protobuf::int32 value) {
  set_has_uav_id();
  uav_id_ = value;
  // @@protoc_insertion_point(field_set:pb_wearable.GetStatus.uav_id)
}

// -------------------------------------------------------------------

// WearableResponse

// required .pb_wearable.WearableResponse.WearableResponseType type = 1;
inline bool WearableResponse::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WearableResponse::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WearableResponse::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WearableResponse::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::pb_wearable::WearableResponse_WearableResponseType WearableResponse::type() const {
  // @@protoc_insertion_point(field_get:pb_wearable.WearableResponse.type)
  return static_cast< ::pb_wearable::WearableResponse_WearableResponseType >(type_);
}
inline void WearableResponse::set_type(::pb_wearable::WearableResponse_WearableResponseType value) {
  assert(::pb_wearable::WearableResponse_WearableResponseType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:pb_wearable.WearableResponse.type)
}

// optional .pb_wearable.Status status = 2;
inline bool WearableResponse::has_status() const {
  return wearableresponse_oneof_case() == kStatus;
}
inline void WearableResponse::set_has_status() {
  _oneof_case_[0] = kStatus;
}
inline void WearableResponse::clear_status() {
  if (has_status()) {
    delete wearableresponse_oneof_.status_;
    clear_has_wearableresponse_oneof();
  }
}
inline const ::pb_wearable::Status& WearableResponse::status() const {
  return has_status() ? *wearableresponse_oneof_.status_
                      : ::pb_wearable::Status::default_instance();
}
inline ::pb_wearable::Status* WearableResponse::mutable_status() {
  if (!has_status()) {
    clear_wearableresponse_oneof();
    set_has_status();
    wearableresponse_oneof_.status_ = new ::pb_wearable::Status;
  }
  return wearableresponse_oneof_.status_;
}
inline ::pb_wearable::Status* WearableResponse::release_status() {
  if (has_status()) {
    clear_has_wearableresponse_oneof();
    ::pb_wearable::Status* temp = wearableresponse_oneof_.status_;
    wearableresponse_oneof_.status_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void WearableResponse::set_allocated_status(::pb_wearable::Status* status) {
  clear_wearableresponse_oneof();
  if (status) {
    set_has_status();
    wearableresponse_oneof_.status_ = status;
  }
}

inline bool WearableResponse::has_wearableresponse_oneof() {
  return wearableresponse_oneof_case() != WEARABLERESPONSE_ONEOF_NOT_SET;
}
inline void WearableResponse::clear_has_wearableresponse_oneof() {
  _oneof_case_[0] = WEARABLERESPONSE_ONEOF_NOT_SET;
}
inline WearableResponse::WearableresponseOneofCase WearableResponse::wearableresponse_oneof_case() const {
  return WearableResponse::WearableresponseOneofCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Status

// optional double x = 1;
inline bool Status::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Status::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Status::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Status::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline double Status::x() const {
  // @@protoc_insertion_point(field_get:pb_wearable.Status.x)
  return x_;
}
inline void Status::set_x(double value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:pb_wearable.Status.x)
}

// optional double y = 2;
inline bool Status::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Status::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Status::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Status::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline double Status::y() const {
  // @@protoc_insertion_point(field_get:pb_wearable.Status.y)
  return y_;
}
inline void Status::set_y(double value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:pb_wearable.Status.y)
}

// optional double z = 3;
inline bool Status::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Status::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Status::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Status::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline double Status::z() const {
  // @@protoc_insertion_point(field_get:pb_wearable.Status.z)
  return z_;
}
inline void Status::set_z(double value) {
  set_has_z();
  z_ = value;
  // @@protoc_insertion_point(field_set:pb_wearable.Status.z)
}

// optional double yaw = 4;
inline bool Status::has_yaw() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Status::set_has_yaw() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Status::clear_has_yaw() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Status::clear_yaw() {
  yaw_ = 0;
  clear_has_yaw();
}
inline double Status::yaw() const {
  // @@protoc_insertion_point(field_get:pb_wearable.Status.yaw)
  return yaw_;
}
inline void Status::set_yaw(double value) {
  set_has_yaw();
  yaw_ = value;
  // @@protoc_insertion_point(field_set:pb_wearable.Status.yaw)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace pb_wearable

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::pb_wearable::WearableRequest_WearableRequestType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pb_wearable::WearableRequest_WearableRequestType>() {
  return ::pb_wearable::WearableRequest_WearableRequestType_descriptor();
}
template <> struct is_proto_enum< ::pb_wearable::WearableResponse_WearableResponseType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pb_wearable::WearableResponse_WearableResponseType>() {
  return ::pb_wearable::WearableResponse_WearableResponseType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_wearable_2eproto__INCLUDED
